<div style="display: flex; flex-direction: column; width: 700px; margin-bottom: 10px;">
    <span>
        These particles are born in the left half of the screen, and are left to wander around...
        After some number of iterations, those who are in the right half of the canvas, <span style="color: blue;">survive</span>, the others, are <i style="color: red;">killed</i>.
        <br>
        Admittedly it's a rough world to live in, but that's life.
        <br>
        <br>
        Each particle has a small (and i mean <i>really small</i>) neural network brain that takes 4 inputs: the distance from the particle to each wall.
        The neural network outputs 2 numbers: these are used as a displacement in the x axis (dx) and a displacement in the y axis (dy).
        <br>
        <br>
        When particles survive the death round, they are grouped in groups of 2 to produce a child particle.
        The child particle's brain is built using parameters from each of its parents, without any particular logic involved. They are then taken to the next round along with their creators.
        <br>
        <br>
        Interestingly, the parameters of each particle's brain are never trained <i>per-se</i>, but simply built out of the parents brains. Another interesting fact is that particles are
        never told to go right; they don't even know how the output of their brain is being used. They essentially have zero feedback from the environment. But since we only keep the particles
        that behaved in a certain way, we end up with a population that has the sought-after characteristics.
        <br>
        <br>
        Next time you see a <a href="https://en.wikipedia.org/wiki/Samara_(fruit)">Samara</a> flying in the wind and wonder how smart nature is to develop these beautiful structures that optimize
        the seed propagation; keep in mind, those who can't compete with this... will die.
    </span>
</div>
<canvas id="canvas"></canvas>
<div id="status"></div>
<div id="population_size" style="width:600px;height:250px;"></div>
<div id="survival_ratio" style="width:600px;height:250px;"></div>
<script src="https://cdn.plot.ly/plotly-2.14.0.min.js"></script>
<script>
const WIDTH = 500
const HEIGHT = 500

const canvas = document.getElementById("canvas")
const ctx = canvas.getContext("2d")

canvas.width = WIDTH
canvas.height = HEIGHT

const population_size_plot = document.getElementById("population_size")
Plotly.newPlot(population_size_plot, [{y: [], type: "scatter"}], {title: "Population size"})

const survival_ratio_plot = document.getElementById("survival_ratio")
Plotly.newPlot(survival_ratio_plot, [{y: [], type: "scatter"}], {title: "Survival ratio"})

const statusText = document.getElementById("status")

const create_matrix = (height, width, init) => {
    return Array.from(Array(height), () => Array.from(Array(width), () => init()))
}

const dot = (matrix1, matrix2) => {
    const height = matrix1.length
    const width = matrix2[0].length
    const output = create_matrix(height, width, () => 0)
    for (var i=0; i<height; i++) {
        for (var j=0; j<width; j++) {
            let tmp = 0
            for (var k=0; k<matrix2.length; k++) {
                tmp += matrix1[i][k] * matrix2[k][j]
            }
            output[i][j] = tmp
        }
    }
    return output
}

const apply = (matrix, fun) => {
    const height = matrix.length
    const width = matrix[0].length
    const output = create_matrix(height, width, () => 0)
    for (var i=0; i<height; i++) {
        for (var j=0; j<width; j++) {
            output[i][j] = fun(matrix[i][j])
        }
    }
    return output
}

class Brain {
    constructor() {
        const r = () => Math.random() - 0.5
        this.weights = create_matrix(4, 4, r)
    }

    process(x, y) {
        // distance ratio to each wall: top, right, bottom, left
        const inputs = [
            [
                y / HEIGHT,
                (WIDTH - x) / WIDTH,
                (HEIGHT - y) / HEIGHT,
                x / WIDTH
            ]
        ]

        // mini neural network
        const output = apply(dot(inputs, this.weights), Math.tanh)
        
        return {
            'dx': output[0][0] - output[0][1],
            'dy': output[0][2] - output[0][3]
        }
    }

    static merge(brain1, brain2) {
        const child = new Brain()

        // inheritance
        child.weights[0] = brain1.weights[0]
        child.weights[1] = brain1.weights[1]
        child.weights[2] = brain2.weights[2]
        child.weights[3] = brain2.weights[3]

        // mutation
        if (Math.random() < 0.05) {
            child.weights[0][0] = Math.random() - 0.5
            child.weights[2][0] = Math.random() - 0.5
        }
        return child
    }
}

class Particle {
    constructor(x, y, size, color) {
        this.x = x
        this.y = y
        this.size = size
        this.color = color
        this.brain = new Brain()
    }

    draw() {
        drawRect(this.x, this.y, this.size, this.size, this.color)
    }

    update() {
        const {dx, dy} = this.brain.process(this.x, this.y)
        this.x += 3 * dx
        this.y += 3 * dy

        if (this.x < 0) {
            this.x = 0
        }
        if (this.x > WIDTH - this.size) {
            this.x = WIDTH - this.size
        }
        if (this.y < 0) {
            this.y = 0
        }
        if (this.y > HEIGHT - this.size) {
            this.y = HEIGHT - this.size
        }
    }
}

const drawRect = (x, y, w, h, color) => {
    ctx.fillStyle = color
    ctx.fillRect(x, y, w, h)
}

const clearCanvas = () => drawRect(0, 0, WIDTH, HEIGHT, "black")

const filterSurvivors = (particles) => {
    return particles.filter(should_survive)
        .map(value => ({ value, sort: Math.random() }))
        .sort((a, b) => a.sort - b.sort)
        .map(({ value }) => value)
}

const reproduceParticles = (particles, max_population) => {
    const new_generation = []
    for (var i=0; i<particles.length - particles.length % 2; i+=2) {
        const child = new_particle()
        child.brain = Brain.merge(particles[i].brain, particles[i + 1].brain)
        
        const parent1 = new_particle()
        parent1.brain = particles[i].brain

        const parent2 = new_particle()
        parent2.brain = particles[i + 1].brain
        
        new_generation.push(parent1)
        new_generation.push(parent2)
        new_generation.push(child)

        if (max_population > 0 && new_generation.length > max_population) {
            break
        }
    }
    return new_generation
}

// CONTROLS NEW PARTICLE CREATION
const new_particle = () => new Particle((WIDTH / 2) * Math.random(), HEIGHT * Math.random(), 3, "yellow")

// SURVIVAL PREDICATE
const should_survive = (particle) => {
    return particle.x > WIDTH / 2
}

// CONTROLS
const fast_forward_epochs = 0
const initial_population = 100
const iterations_per_epoch = 200
const total_epochs = 20
const max_population_size = 15000

const population_size = [initial_population]
const survival_ratio = []

let particles = Array.from(Array(initial_population), new_particle)
let current_iteration = 1
let current_epoch = 0

const update = () => {
    const should_draw = current_epoch >= fast_forward_epochs
    statusText.innerText = `epoch: ${current_epoch}/${total_epochs}`

    if (should_draw) {
        clearCanvas()
    }

    for (let p of particles) {
        p.update()
        if (should_draw) {
            p.draw()
        }
    }

    if (current_iteration % iterations_per_epoch == 0) {
        const sizeBefore = particles.length
        particles = filterSurvivors(particles)
        survival_ratio.push(particles.length / sizeBefore)
        Plotly.update(survival_ratio_plot, {y: [survival_ratio]})

        particles = reproduceParticles(particles, max_population_size)
        population_size.push(particles.length)
        Plotly.update(population_size_plot, {y: [population_size]})

        current_epoch++
        if (current_epoch - 1 == total_epochs) {
            return
        }
    }

    current_iteration++
    if (should_draw) {
        requestAnimationFrame(update)
    }
}

for (var i=0; i<=fast_forward_epochs * iterations_per_epoch; i++) {
    update()
}

</script>